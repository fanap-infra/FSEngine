
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>FSEngine: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/fanap-infra/FSEngine/IO.go (0.0%)</option>
				
				<option value="file1">github.com/fanap-infra/FSEngine/blocks.go (0.0%)</option>
				
				<option value="file2">github.com/fanap-infra/FSEngine/crud.go (0.0%)</option>
				
				<option value="file3">github.com/fanap-infra/FSEngine/file.go (0.0%)</option>
				
				<option value="file4">github.com/fanap-infra/FSEngine/internal/Header/IO.go (71.4%)</option>
				
				<option value="file5">github.com/fanap-infra/FSEngine/internal/Header/configs.go (80.0%)</option>
				
				<option value="file6">github.com/fanap-infra/FSEngine/internal/Header/crud.go (0.0%)</option>
				
				<option value="file7">github.com/fanap-infra/FSEngine/internal/Header/fileIndex.go (71.8%)</option>
				
				<option value="file8">github.com/fanap-infra/FSEngine/internal/Header/fs.go (0.0%)</option>
				
				<option value="file9">github.com/fanap-infra/FSEngine/internal/Header/header.go (85.7%)</option>
				
				<option value="file10">github.com/fanap-infra/FSEngine/internal/Header/provider.go (66.0%)</option>
				
				<option value="file11">github.com/fanap-infra/FSEngine/internal/blockAllocationMap/blockAllocationMap.go (95.5%)</option>
				
				<option value="file12">github.com/fanap-infra/FSEngine/internal/blockAllocationMap/provider.go (84.6%)</option>
				
				<option value="file13">github.com/fanap-infra/FSEngine/internal/fileIndex/fileIndex.go (88.5%)</option>
				
				<option value="file14">github.com/fanap-infra/FSEngine/internal/fileIndex/fileIndex.pb.go (50.0%)</option>
				
				<option value="file15">github.com/fanap-infra/FSEngine/internal/fileIndex/provider.go (100.0%)</option>
				
				<option value="file16">github.com/fanap-infra/FSEngine/provider.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package fsEngine

import (
        "fmt"
)

func (fse *FSEngine) writeInBlock(data []byte, blockIndex uint32) (n int, err error) <span class="cov0" title="0">{
        if blockIndex &gt;= fse.blocks </span><span class="cov0" title="0">{
                return 0, ErrBlockIndexOutOFRange
        }</span>

        <span class="cov0" title="0">n, err = fse.file.WriteAt(data, int64(blockIndex)*int64(fse.blockSize))
        if err != nil </span><span class="cov0" title="0">{
                fse.log.Infov("Error Writing to file", "err", err.Error(), "file", fse.file.Name())
        }</span>

        <span class="cov0" title="0">return</span>
}

func (fse *FSEngine) readBlock(blockIndex uint32) ([]byte, error) <span class="cov0" title="0">{
        if blockIndex &gt;= fse.blocks </span><span class="cov0" title="0">{
                return nil, ErrBlockIndexOutOFRange
        }</span>

        <span class="cov0" title="0">var err error
        buf := make([]byte, fse.blockSize)
        n, err := fse.file.ReadAt(buf, int64(blockIndex*fse.blockSize))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if n != int(fse.blockSize) </span><span class="cov0" title="0">{
                return buf, ErrDataBlockMismatch
        }</span>

        <span class="cov0" title="0">return buf, nil</span>
}

func (fse *FSEngine) ReadAt(data []byte, off int64, fileID uint32) (int, error) <span class="cov0" title="0">{
        fse.rIBlockMux.Lock()
        defer fse.rIBlockMux.Unlock()
        // ToDo: implement it
        return 0, nil
}</span>

func (fse *FSEngine) Read(data []byte, fileID uint32) (int, error) <span class="cov0" title="0">{
        // ToDo:  implement
        return 0, fmt.Errorf("please impkement me")
}</span>

func (fse *FSEngine) WriteAt(b []byte, off int64, fileID uint32) (n int, err error) <span class="cov0" title="0">{
        // ToDo: complete it
        n, err = fse.file.WriteAt(b, off)

        //if arc.LastFiletime.IsZero() &amp;&amp; off &gt;= int64(arc.conf.DataStartBlock) {
        //        arc.LastFiletime = time.Now()
        //}
        return
}</span>

func (fse *FSEngine) Write(data []byte, fileID uint32) (int, error) <span class="cov0" title="0">{
        fse.rIBlockMux.Lock()
        defer fse.rIBlockMux.Unlock()
        vf, ok := fse.openFiles[fileID]
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("this file ID: %v did not opened", fileID)
        }</span>
        <span class="cov0" title="0">n := 0
        blocksNum := uint32(len(data) / BLOCKSIZEUSABLE)
        for i := uint32(0); i &lt; blocksNum; i++ </span><span class="cov0" title="0">{
                previousBlock := vf.GetLastBlock()
                blockID := fse.blockAllocationMap.FindNextFreeBlockAndAllocate()
                err := vf.AddBlockID(blockID)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">d, err := fse.prepareBlock(data, fileID, previousBlock, blockID)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">c, err := fse.writeInBlock(d, blockID)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if c != len(d) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("block with size: %v did not write correctly, n = %v", c, len(d))
                }</span>
                <span class="cov0" title="0">n = c + n</span>
        }

        <span class="cov0" title="0">if len(data) != int(blocksNum*BLOCKSIZEUSABLE) </span><span class="cov0" title="0">{
                previousBlock := vf.GetLastBlock()
                blockID := fse.blockAllocationMap.FindNextFreeBlockAndAllocate()
                err := vf.AddBlockID(blockID)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">d, err := fse.prepareBlock(data, fileID, previousBlock, blockID)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">c, err := fse.writeInBlock(d, blockID)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if c != len(d) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("block with size: %v did not write correctly, n = %v", c, len(d))
                }</span>
                <span class="cov0" title="0">n = c + n</span>
        }

        <span class="cov0" title="0">return 0, nil</span>
}

//type FS interface {
//        Write(data []byte, fileID uint32) (int, error)
//        WriteAt(data []byte, off int64, fileID uint32) (int, error)
//        Read(data []byte, fileID uint32) (int, error)
//        ReadAt(data []byte, off int64, fileID uint32) (int, error)
//        Close(fileID uint32) error
//}
</pre>
		
		<pre class="file" id="file1" style="display: none">package fsEngine

import (
        "encoding/binary"
)

func (fse *FSEngine) NoSpace() uint32 <span class="cov0" title="0">{
        return 0
}</span>

// BlockStructure
//        +===============+===============+===============+=======+
//        |                                               BLOCK                                                    |
//        +--------+------+--------+------+--------+------+-------+
//        |  blockID  |   fileID          |         prevBlock         | valid Size         |
//        +--------+------+--------+------+--------+------+-------+
//  |  4 byte   |   4 byte   |    4 byte     |   4 byte     |   16 Byte
//        +--------+------+--------+------+--------+------+-------+
// Warning It is not thread safe
func (fse *FSEngine) prepareBlock(data []byte, fileID uint32, previousBlock uint32, blockID uint32) ([]byte, error) <span class="cov0" title="0">{
        dataTmp := make([]byte, 0)

        a := make([]byte, 16)
        binary.BigEndian.PutUint32(a, blockID)
        binary.BigEndian.PutUint32(a, fileID)
        binary.BigEndian.PutUint32(a, previousBlock)
        binary.BigEndian.PutUint32(a, uint32(len(data)))
        dataTmp = append(dataTmp, a...)
        dataTmp = append(dataTmp, data...)

        return dataTmp, nil
}</span>

/*
var byteOrder = binary.BigEndian

var errCorruptBlock = errors.New("corrupt block")

// readBlock takes the raw bytes of a block, reads and parses the footer
// and returns a block with the footer indexes.
func readBlock(raw []byte) (block, error) {
        if len(raw) &lt; 4 {
                return block{}, errCorruptBlock
        }

        // the trailing 4 bytes are a uint32 specifying the offset
        // of where the footer begins.
        footerOff := byteOrder.Uint32(raw[len(raw)-4:])
        if int(footerOff) &gt;= len(raw) {
                return block{}, errCorruptBlock
        }

        footer := bytes.NewReader(raw[footerOff : len(raw)-4])
        restarts := make([]uint32, 0)
        for footer.Len() &gt; 0 {
                off, err := binary.ReadUvarint(footer)
                if err != nil {
                        return block{}, err
                }
                if int(off) &gt;= len(raw) {
                        return block{}, errCorruptBlock
                }
                restarts = append(restarts, uint32(off))
        }

        return block{
                data:     raw[:footerOff],
                restarts: restarts,
        }, nil
}

type block struct {
        data     []byte   // raw block, without footer
        restarts []uint32 // parsed footer
}

// iter iterates over the block calling fn on each key-value pair.
// The key bytes are owned by iter and are only valid until fn
// returns. The value is a slice of the block's bytes. Keeping
// a reference to it will prevent GC-ing of the block.
func (b block) iter(fn func(key, val []byte)) error {
        it := blockIterator{block: b}
        for it.hasNext() {
                err := it.next()
                if err != nil {
                        return err
                }

                fn(it.key, it.value)
        }
        return nil
}

// iterAt returns a block iterator starting at the provided
// key, or where the provided key would be if it were contained
// in the block. It binary searches among the block's restart
// points and linear scans from there.
func (b block) iterAt(key []byte) (blockIterator, error) {
        bi := blockIterator{block: b}

        var decodeErr error
        i := sort.Search(len(b.restarts), func(r int) bool {
                bi.off = int(b.restarts[r])
                err := bi.next()
                if err != nil {
                        decodeErr = err
                        return false
                }

                return bytes.Compare(bi.key, key) &gt;= 0
        })
        if decodeErr != nil {
                return bi, decodeErr
        }

        // i is now the index of the smallest restart point &gt;= key.
        // We now linear scan from the i-1 restart point.
        if i == 0 {
                // Scan from the beginning of the block, not the first
                // restart point which is already several keys into the
                // block.
                bi.off = 0
        } else {
                bi.off = int(b.restarts[i-1])
        }

        for bi.hasNext() {
                err := bi.next()
                if err != nil {
                        return bi, err
                }
                if bytes.Compare(bi.key, key) &gt;= 0 {
                        break
                }
        }
        return bi, nil
}

type blockIterator struct {
        block block
        off   int

        entryOff   int
        key, value []byte
}

func (bi blockIterator) hasNext() bool {
        return bi.off &lt; len(bi.block.data)
}

func (bi *blockIterator) ReadByte() (byte, error) {
        if bi.off &gt;= len(bi.block.data) {
                return 0, io.ErrUnexpectedEOF
        }
        b := bi.block.data[bi.off]
        bi.off++
        return b, nil
}

func (bi *blockIterator) next() error {
        startOff := bi.off
        shared, err := binary.ReadUvarint(bi)
        if err != nil {
                return err
        }
        nonshared, err := binary.ReadUvarint(bi)
        if err != nil {
                return err
        }
        valueLen, err := binary.ReadUvarint(bi)
        if err != nil {
                return err
        }

        rest := bi.block.data[bi.off:]

        // set bi.key, bi.value for the next value
        keyDelta := rest[:nonshared]
        bi.key = bi.key[:shared]
        bi.key = append(bi.key, keyDelta...)
        bi.value = rest[nonshared : nonshared+valueLen]
        bi.off += int(nonshared + valueLen)
        bi.entryOff = startOff
        return nil
}

// blockBuilder generates blocks with prefix-compressed keys.
//
// Every restartInterval keys blockBuilder will restart the
// prefix compression. It saves the restart offset to restarts.
// Upon finishing the block, the restarts are added to the end.
// A read may binary search through the restart points to find
// where to begin searching.
type blockBuilder struct {
        buf             bytes.Buffer
        lastKey         []byte
        counter         int
        restartInterval int
        restarts        []int
        tmp             [binary.MaxVarintLen64]byte // varint scratch space
}

// Reset resets the builder to be empty,
// but it retains the underlying storage for use by future writes.
func (bb *blockBuilder) reset() {
        bb.buf.Reset()
        bb.lastKey = nil
        bb.counter = 0
        bb.restarts = nil
}

// size estimates the size of the finished block
func (bb *blockBuilder) size() int {
        return bb.buf.Len() + 4*len(bb.restarts)
}

func (bb *blockBuilder) finish() []byte {
        // Write the restart offsets too as a footer. All integers
        // are written as uvarints except for the final offset, which
        // is written as a uint32.
        // [r_0 | uvarint] [r_1 | uvarint] ... [r_n | uvarint] [offset of r_0 | uint32]
        restartsOff := bb.buf.Len()
        for _, off := range bb.restarts {
                bb.putUvarint(off)
        }
        var tmp [4]byte
        byteOrder.PutUint32(tmp[:], uint32(restartsOff))
        bb.buf.Write(tmp[:])
        return bb.buf.Bytes()
}

func (bb *blockBuilder) add(k, v []byte) {
        shared := 0
        if bb.counter &gt;= bb.restartInterval {
                bb.restarts = append(bb.restarts, bb.buf.Len())
                bb.counter = 0
        } else {
                // Count how many characters are shared between k and lastKey
                minLen := len(bb.lastKey)
                if len(k) &lt; minLen {
                        minLen = len(k)
                }
                for shared &lt; minLen &amp;&amp; bb.lastKey[shared] == k[shared] {
                        shared++
                }
        }
        nonshared := len(k) - shared

        // Write the lengths: shared key, unshared key, value
        bb.putUvarint(shared)
        bb.putUvarint(nonshared)
        bb.putUvarint(len(v))

        // Write the unshared key bytes and the value
        bb.buf.Write(k[shared:])
        bb.buf.Write(v)

        bb.lastKey = k
        bb.counter++
}

func (bb *blockBuilder) putUvarint(v int) {
        b := binary.PutUvarint(bb.tmp[:], uint64(v))
        bb.buf.Write(bb.tmp[:b])
}
*/
</pre>
		
		<pre class="file" id="file2" style="display: none">package fsEngine

import (
        "github.com/fanap-infra/FSEngine/internal/virtualFile"
        "fmt"
)

// ToDO: completeCRUD

func (fse *FSEngine) NewVirtualFile(id uint32, fileName string) (*virtualFile.VirtualFile, error) <span class="cov0" title="0">{
        fse.crudMutex.Lock()
        defer fse.crudMutex.Unlock()
        if fse.header.CheckIDExist(id) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("this ID: %v, had been taken", id)
        }</span>
        //vf := virtualFile.NewVirtualFile(fileName, id, fse, fse, fse.log)
        //err := fse.header.AddVirtualFile(id, fileName)
        //if err != nil {
        //        return nil, err
        //}
        //return vf, nil
        <span class="cov0" title="0">return nil, nil</span>
}

func (fse *FSEngine) OpenVirtualFile(id uint32) (*virtualFile.VirtualFile, error) <span class="cov0" title="0">{
        fse.crudMutex.Lock()
        defer fse.crudMutex.Unlock()
        if !fse.header.CheckIDExist(id) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("this ID: %v does not exist", id)
        }</span>
        //vf := virtualFile.OpenVirtualFile()
        //err := fse.header.AddVirtualFile(id, fileName)
        //if err != nil {
        //        return nil, err
        //}
        <span class="cov0" title="0">return nil, nil</span>
}

func (fse *FSEngine) DeleteVirtualFile(id uint32) error <span class="cov0" title="0">{
        fse.crudMutex.Lock()
        defer fse.crudMutex.Unlock()
        _, ok := fse.openFiles[id]
        if ok </span><span class="cov0" title="0">{
                return fmt.Errorf("virtual file id : %d is opened", id)
        }</span>
        //fse.header.
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package fsEngine

import (
        "github.com/fanap-infra/FSEngine/internal/fileIndex"
        Header_ "github.com/fanap-infra/FSEngine/internal/Header"
        "github.com/fanap-infra/FSEngine/internal/blockAllocationMap"
        "github.com/fanap-infra/FSEngine/internal/virtualFile"
        "os"
        "sync"
        "time"

        "github.com/fanap-infra/log"

        lru "github.com/hashicorp/golang-lru"
)

// File
type FSEngine struct {
        file               *os.File // file handle instance
        header             *Header_.HFileSystem
        version            uint32
        size               int64
        CurrentFile        string                                 // name of the latest file to be created
        LastFiletime       time.Time                              // time where the first data of the file has been written
        blocks             uint32                                 // total number of blocks in Archiver
        blockSize          uint32                                 // in bytes, size of each block
        lastWrittenBlock   uint32                                 // the last block that has been written into
        blockAllocationMap *blockAllocationMap.BlockAllocationMap // BAM data in memory coded with roaring, to be synced later on to Disk.
        openFiles          map[uint32]*virtualFile.VirtualFile
        fileIndex          fileIndex.FileIndex
        WMux               sync.Mutex
        RMux               sync.Mutex
        log                *log.Logger
        fiMux              sync.RWMutex
        fiChecksum         uint32
        bamChecksum        uint32
        fsMux              sync.Mutex
        rIBlockMux         sync.Mutex
        crudMutex          sync.Mutex
        Cache              *lru.Cache
        fileIndexIsFlip    bool
        EventsHandler      Events
        Quit               chan struct{}
}

// Close ...
func (fse *FSEngine) Close() error <span class="cov0" title="0">{
        err := fse.header.UpdateFSHeader()
        if err != nil </span><span class="cov0" title="0">{
                fse.log.Warnv("Can not updateHeader", "err", err.Error())
                // ToDo: remove it
                return err
        }</span>
        // ToDo:update file system
        <span class="cov0" title="0">err = fse.file.Sync()
        if err != nil </span><span class="cov0" title="0">{
                fse.log.Warnv("Can not sync file", "err", err.Error())
                // ToDo: remove it
                return err
        }</span>
        <span class="cov0" title="0">return fse.file.Close()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package Header_

import "encoding/binary"

func (hfs *HFileSystem) writeAt(b []byte, off int64) (n int, err error) <span class="cov8" title="1">{
        n, err = hfs.file.WriteAt(b, off)

        return
}</span>

// Close ...
func (hfs *HFileSystem) Close() error <span class="cov8" title="1">{
        err := hfs.updateHeader()
        if err != nil </span><span class="cov0" title="0">{
                hfs.log.Warnv("Can not updateHeader", "err", err.Error())
                // ToDo: remove it
                return err
        }</span>
        // ToDo:update file system
        <span class="cov8" title="1">err = hfs.file.Sync()
        if err != nil </span><span class="cov0" title="0">{
                hfs.log.Warnv("Can not sync file", "err", err.Error())
                // ToDo: remove it
                return err
        }</span>
        <span class="cov8" title="1">return hfs.file.Close()</span>
}

func (hfs *HFileSystem) writeEOPart(off int64) (n int, err error) <span class="cov8" title="1">{
        buf := make([]byte, 4)
        binary.BigEndian.PutUint32(buf, EOPart)
        return hfs.file.WriteAt(buf, off)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package Header_

type configs struct {
        BLOCKSIZE                   uint32 // = 1 &lt;&lt; 19
        BLOCKSIZEUSABLE             uint32 // BLOCKSIZE - 20 // usable size is block size minus two uint32 sized locations reserved for
        StorageMaxSize              uint64 // 1 &lt;&lt; 44
        DataStartBlock              uint32
        FileIndexReservedSize       uint32 // 1 &lt;&lt; 22 // 4MB in continuous blocks is reserved for fileIndex
        FileIndexReservedSizeBlocks uint32 //(FileIndexReservedSize / BLOCKSIZEUSABLE) * 2
        // ***
        //        Block Allocation Map is a BitMap of all the blocks in Archiver, hence it is
        //        calculated by dividing maximum storage size by block size divided by 8.
        //        Even when storage size is lower than maximum, BAM is reserved for the maximum
        //        because Archiver size can be increased in code later on.
        // ***
        BlockAllocationMapSize uint32
}

func loadConf(hfs *HFileSystem) <span class="cov8" title="1">{
        hfs.conf.BLOCKSIZE = hfs.blockSize // 1 &lt;&lt; 19
        hfs.conf.BLOCKSIZEUSABLE = hfs.conf.BLOCKSIZE - 20
        hfs.conf.StorageMaxSize = 1 &lt;&lt; 44
        hfs.conf.BlockAllocationMapSize = uint32(hfs.conf.StorageMaxSize/uint64(hfs.conf.BLOCKSIZEUSABLE)) / 8 // Size in blocks.
        hfs.conf.FileIndexReservedSize = 1 &lt;&lt; 22
        hfs.conf.FileIndexReservedSizeBlocks = (hfs.conf.FileIndexReservedSize / hfs.conf.BLOCKSIZEUSABLE) * 2 //(FileIndexReservedSize / BLOCKSIZEUSABLE) * 2
        hfs.conf.DataStartBlock = (hfs.conf.BlockAllocationMapSize / hfs.conf.BLOCKSIZEUSABLE) + hfs.conf.FileIndexReservedSizeBlocks + 1
        hfs.lastWrittenBlock = hfs.conf.DataStartBlock
}</span>

func (hfs *HFileSystem) GetBlockSize() uint32 <span class="cov0" title="0">{
        return hfs.blockSize
}</span>

func (hfs *HFileSystem) GetBlocksNumber() uint32 <span class="cov0" title="0">{
        return hfs.blocks
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package Header_

func (hfs *HFileSystem) CheckIDExist(id uint32) bool <span class="cov0" title="0">{
        return hfs.fileIndex.CheckFileExistWithLock(id)
}</span>

func (hfs *HFileSystem) AddVirtualFile(id uint32, fileName string) error <span class="cov0" title="0">{
        return hfs.fileIndex.AddFile(id, fileName)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package Header_

import (
        "bytes"
        "compress/gzip"
        "fmt"
        "hash/crc32"
)

func (hfs *HFileSystem) generateFileIndex() ([]byte, error) <span class="cov8" title="1">{
        bin, err := hfs.fileIndex.GenerateBinary()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">pw := bytes.Buffer{}

        zw, err := gzip.NewWriterLevel(&amp;pw, 2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, _ = zw.Write(bin)
        err = zw.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">bin = pw.Bytes()
        return bin, nil</span>
}

func (hfs *HFileSystem) updateFileIndex() error <span class="cov8" title="1">{
        fi, err := hfs.generateFileIndex()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">checkSum := crc32.ChecksumIEEE(fi)
        if hfs.fiChecksum == crc32.ChecksumIEEE(fi) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">hfs.fiChecksum = checkSum
        hfs.fileIndexSize = uint32(len(fi))
        n, err := hfs.file.WriteAt(fi, FileIndexByteIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if n != len(fi) </span><span class="cov0" title="0">{
                return fmt.Errorf("fileIndex did not write complete, header size: %v, written size: %v", len(fi), n)
        }</span>
        <span class="cov8" title="1">n, err = hfs.writeEOPart(int64(FileIndexByteIndex + n))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if n != 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("fileIndex did not write complete, header size: %v, written size: %v", len(fi), n)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (hfs *HFileSystem) parseFileIndex() error <span class="cov8" title="1">{
        buf := make([]byte, hfs.fileIndexSize)

        n, err := hfs.file.ReadAt(buf, FileIndexByteIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if n != int(hfs.fileIndexSize) </span><span class="cov0" title="0">{
                return ErrDataBlockMismatch
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package Header_

import (
        "github.com/fanap-infra/FSEngine/internal/blockAllocationMap"
        "github.com/fanap-infra/FSEngine/internal/fileIndex"
        "os"
        "time"

        "github.com/fanap-infra/log"
)

type HFileSystem struct {
        file               *os.File // file handle instance
        version            uint32
        size               int64
        CurrentFile        string                                 // name of the latest file to be created
        LastFiletime       time.Time                              // time where the first data of the file has been written
        blocks             uint32                                 // total number of blocks in Archiver
        blockSize          uint32                                 // in bytes, size of each block
        lastWrittenBlock   uint32                                 // the last block that has been written into
        blockAllocationMap *blockAllocationMap.BlockAllocationMap // BAM data in memory coded with roaring, to be synced later on to Disk.
        //openFiles          map[uint32]*virtualFile.VirtualFile
        fileIndex          *fileIndex.FileIndex
        fileIndexSize      uint32
        // WMux               sync.Mutex
        // RMux               sync.Mutex
        log *log.Logger
        // fiMux              sync.RWMutex
        fiChecksum uint32
        // bamChecksum uint32
        // fsMux              sync.Mutex
        // rIBlockMux         sync.Mutex
        // Cache              *lru.Cache
        // fileIndexIsFlip    bool
        conf configs
}

func (hfs *HFileSystem) UpdateFSHeader() error <span class="cov0" title="0">{
        err := hfs.updateFileIndex()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = hfs.updateHeader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package Header_

import (
        "encoding/binary"
        "fmt"
)

// generate Header
//         +------------+---------+-----------+------------+------------+---------------+
//        | Identifier | Version | BLOCKSIZE | BLOCKCOUNT | LastWBlock | FileIndexSize |
//        +============+=========+===========+============+============+===============+
//        |   8 BYTES  | 4 BYTES |  8 BYTES  |   8 BYTES  |   8 BYTES  |     8 BYTES   |
//        +------------+---------+-----------+------------+------------+---------------+
//        |    CONST   |  uint32 |   uint64  |   uint64   |   uint64   |     uint64    |
//        +------------+---------+-----------+------------+------------+---------------+
//
func (hfs *HFileSystem) generateHeader() (header []byte) <span class="cov8" title="1">{
        header = make([]byte, 0)
        tmp32 := make([]byte, 4)
        tmp64 := make([]byte, 8)

        // byte Identifier
        header = append(header, []byte(FileSystemIdentifier)...)

        // byte Version
        binary.BigEndian.PutUint32(tmp32, hfs.version)
        header = append(header, tmp32...)

        // blocksize, corresponds to BLOCKSIZE
        binary.BigEndian.PutUint64(tmp64, uint64(hfs.blockSize))
        header = append(header, tmp64...)

        // number of blocks
        binary.BigEndian.PutUint64(tmp64, uint64(hfs.blocks))
        header = append(header, tmp64...)

        // last written block
        binary.BigEndian.PutUint64(tmp64, uint64(hfs.lastWrittenBlock))
        header = append(header, tmp64...)

        // file index size
        binary.BigEndian.PutUint64(tmp64, uint64(hfs.fileIndexSize))
        header = append(header, tmp64...)

        //// *** why add this line ???
        //dataTmp := make([]byte, fs.blockSize-uint32(len(header)))
        //header = append(header, dataTmp...)
        return
}</span>

func (hfs *HFileSystem) updateHeader() error <span class="cov8" title="1">{
        header := hfs.generateHeader()
        headerSize := len(header)
        dataTmp := make([]byte, hfs.blockSize-uint32(headerSize))
        dataTmp = append(header, dataTmp...)

        n, err := hfs.writeAt(dataTmp, HeaderBlockIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if n != len(dataTmp) </span><span class="cov0" title="0">{
                return fmt.Errorf("Header did not write complete, header size: %v, written size: %v", len(dataTmp), n)
        }</span>
        // ToDo:Maybe it does not be necessary
        <span class="cov8" title="1">err = hfs.file.Sync()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //// write header back up
        //n, err = fs.WriteAt(header, fs.size-int64(headerSize))
        //if err != nil {
        //        return err
        //}
        //if n != len(header) {
        //        return fmt.Errorf("Header did not write complete, header size: %v, written size: %v", headerSize, n)
        //}

        <span class="cov8" title="1">return nil</span>
}

func (hfs *HFileSystem) parseHeader() error <span class="cov8" title="1">{
        buf := make([]byte, HeaderByteSize)

        n, err := hfs.file.ReadAt(buf, HeaderBlockIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if n != HeaderByteSize </span><span class="cov0" title="0">{
                return ErrDataBlockMismatch
        }</span>
        // read header
        <span class="cov8" title="1">if string(buf[:len(FileSystemIdentifier)]) != FileSystemIdentifier </span><span class="cov0" title="0">{
                return ErrArchiverIdentifier

                //// read backup header
                //fs.log.Warnv("First file header is corrupted", "byte array", buf)
                //
                //n, err := fs.file.ReadAt(buf, fs.size-HeaderByteSize)
                //if err != nil {
                //        return err
                //}
                //if n != HeaderByteSize {
                //        return ErrDataBlockMismatch
                //}
                //if string(buf[:len(FileSystemIdentifier)]) != FileSystemIdentifier {
                //        return ErrArchiverIdentifier
                //}
        }</span>
        // ToDO:make compatible for multiple versions

        <span class="cov8" title="1">hfs.version = binary.BigEndian.Uint32(buf[8:12])
        hfs.blockSize = uint32(binary.BigEndian.Uint64(buf[12:20]))
        hfs.blocks = uint32(binary.BigEndian.Uint64(buf[20:28]))
        hfs.lastWrittenBlock = uint32(binary.BigEndian.Uint64(buf[28:36]))
        hfs.fileIndexSize = uint32(binary.BigEndian.Uint64(buf[36:44]))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package Header_

import (
        "crypto/rand"
        "errors"
        "fmt"
        "github.com/fanap-infra/FSEngine/internal/blockAllocationMap"
        "github.com/fanap-infra/FSEngine/internal/fileIndex"
        "github.com/fanap-infra/FSEngine/pkg/utils"
        "os"

        "github.com/fanap-infra/log"
)

func CreateHeaderFS(path string, size int64, blockSize uint32, log *log.Logger, eventHandler blockAllocationMap.Events) (*HFileSystem, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, errors.New("path cannot be empty")
        }</span>

        <span class="cov8" title="1">if blockSize &lt; HeaderByteSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Block size must be greater than %v", blockSize)
        }</span>

        <span class="cov8" title="1">if utils.FileExists(path) </span><span class="cov0" title="0">{
                return nil, errors.New("File already exists")
        }</span>
        <span class="cov8" title="1">if size%int64(blockSize) != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("File size must be divisible by %v", blockSize)
        }</span>
        <span class="cov8" title="1">if size &lt; int64(blockSize*60) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("File size is too small, Minimum size is %v", blockSize*60)
        }</span>

        <span class="cov8" title="1">file, err := utils.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o777)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // make file with size
        <span class="cov8" title="1">token := make([]byte, blockSize)
        _, err = rand.Read(token)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorv("generate rand token ", "err", err.Error())
        }</span>
        <span class="cov8" title="1">n, err := file.WriteAt(token, size-int64(blockSize))
        if err != nil </span><span class="cov0" title="0">{
                log.Warnv("write token ", "err", err.Error())
        }</span>
        <span class="cov8" title="1">if uint32(n) != blockSize </span><span class="cov0" title="0">{
                log.Warnv("Does not write completely ", "err", err.Error(), "n", n)
        }</span>

        <span class="cov8" title="1">fs := &amp;HFileSystem{
                file:               file,
                size:               size,
                version:            FileSystemVersion,
                blocks:             uint32(size / int64(blockSize)),
                blockSize:          blockSize,
                //openFiles:          make(map[uint32]*virtualFile.VirtualFile),
                fileIndex:          fileIndex.NewFileIndex(),
                blockAllocationMap: blockAllocationMap.New(log, eventHandler, uint32(size/int64(blockSize))),
                log:                log,
        }

        loadConf(fs)

        err = fs.updateFileIndex()
        if err != nil </span><span class="cov0" title="0">{
                // p.log.Errorv("updateFileIndex ", "err", err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">err = fs.updateHeader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return fs, nil</span>
}

func ParseHeaderFS(path string, log *log.Logger) (*HFileSystem, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, errors.New("path cannot be empty")
        }</span>
        <span class="cov8" title="1">size, err := utils.FileSize(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">file, err := utils.OpenFile(path, os.O_RDWR, 0o777)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fs := &amp;HFileSystem{
                file:      file,
                size:      size,
                //openFiles: make(map[uint32]*virtualFile.VirtualFile),
                log:       log,
        }

        err = fs.parseHeader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = fs.parseFileIndex()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return fs, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package blockAllocationMap

import (
        "fmt"

        "github.com/fanap-infra/log"

        "github.com/RoaringBitmap/roaring"
)

type BlockAllocationMap struct {
        rMap             *roaring.Bitmap // BAM data in memory coded with roaring, to be synced later on to Disk.
        LastWrittenBlock uint32
        size             uint32
        // numberOfAllocated uint32
        trigger Events
        log     *log.Logger
}

func (blm *BlockAllocationMap) ToArray() []uint32 <span class="cov8" title="1">{
        return blm.rMap.ToArray()
}</span>

func (blm *BlockAllocationMap) SetBlockAsAllocated(blockIndex uint32) error <span class="cov8" title="1">{
        if blm.IsBlockAllocated(blockIndex) </span><span class="cov8" title="1">{
                return fmt.Errorf("Block number %v is allocated before", blockIndex)
        }</span>
        <span class="cov8" title="1">blm.LastWrittenBlock = blockIndex
        blm.rMap.Add(blockIndex)
        return nil</span>
}

func (blm *BlockAllocationMap) UnsetBlockAsAllocated(blockIndex uint32) <span class="cov8" title="1">{
        blm.rMap.Remove(blockIndex)
}</span>

func (blm *BlockAllocationMap) IsBlockAllocated(blockIndex uint32) bool <span class="cov8" title="1">{
        return blm.rMap.Contains(blockIndex)
}</span>

func (blm *BlockAllocationMap) FindNextFreeBlockAndAllocate() uint32 <span class="cov8" title="1">{
        alloc := true
        freeIndex := blm.LastWrittenBlock
        for alloc </span><span class="cov8" title="1">{
                // iterate
                freeIndex += 1
                // ToDo: check full space by size
                if freeIndex == blm.LastWrittenBlock </span><span class="cov8" title="1">{
                        blm.log.Warnv("There is no space", "freeIndex", freeIndex, "LastWrittenBlock", blm.LastWrittenBlock)
                        freeIndex = blm.trigger.NoSpace()
                        blm.UnsetBlockAsAllocated(freeIndex)
                        return freeIndex
                }</span>
                <span class="cov8" title="1">if freeIndex == blm.size </span><span class="cov8" title="1">{
                        freeIndex = 0
                        continue</span>
                }
                <span class="cov8" title="1">alloc = blm.IsBlockAllocated(freeIndex)</span>
        }

        <span class="cov0" title="0">return freeIndex</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package blockAllocationMap

import (
        "bytes"

        "github.com/RoaringBitmap/roaring"
        "github.com/fanap-infra/log"
)

func New(log *log.Logger, listener Events, size uint32) *BlockAllocationMap <span class="cov8" title="1">{
        return &amp;BlockAllocationMap{
                size:             size,
                log:              log,
                trigger:          listener,
                LastWrittenBlock: 0,
                rMap:             roaring.NewBitmap(),
        }
}</span>

// ToDo: add block allocation map parser

func Open(log *log.Logger, listener Events, size uint32, lastWrittenBlock uint32, rMapByte []byte) (*BlockAllocationMap, error) <span class="cov8" title="1">{
        rMap := roaring.NewBitmap()
        b := bytes.NewReader(rMapByte)
        _, err := rMap.ReadFrom(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;BlockAllocationMap{
                size:             size,
                log:              log,
                trigger:          listener,
                LastWrittenBlock: lastWrittenBlock,
                rMap:             rMap,
        }, nil</span>
}

func Marshal(bAllocationMap *BlockAllocationMap) ([]byte, error) <span class="cov8" title="1">{
        bAllocationMap.rMap.RunOptimize()
        byteArray := bytes.Buffer{}
        _, err := bAllocationMap.rMap.WriteTo(&amp;byteArray)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return byteArray.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package fileIndex

import (
        "fmt"
        "sync"
)

const (
        HashTableSize = 0
)

type FileIndex struct {
        table *Table
        rwMux sync.Mutex
}

func (i *FileIndex) AddFile(fileId uint32, name string) error <span class="cov8" title="1">{
        i.rwMux.Lock()
        defer i.rwMux.Unlock()
        if i.checkFileExist(fileId) </span><span class="cov0" title="0">{
                return fmt.Errorf("file id %v has been added before", fileId)
        }</span>
        <span class="cov8" title="1">i.table.NumberFiles++
        i.table.Files[fileId] = &amp;File{Id: fileId, FirstBlock: 0, LastBlock: 0, Name: name, RMapBlocks: make([]byte, 0)}
        return nil</span>
}

func (i *FileIndex) checkFileExist(fileId uint32) bool <span class="cov8" title="1">{
        _, isExist := i.table.Files[fileId]
        return isExist
}</span>

func (i *FileIndex) CheckFileExistWithLock(fileId uint32) bool <span class="cov8" title="1">{
        i.rwMux.Lock()
        defer i.rwMux.Unlock()
        _, isExist := i.table.Files[fileId]
        return isExist
}</span>

func (i *FileIndex) RemoveFile(fileId uint32) error <span class="cov8" title="1">{
        i.rwMux.Lock()
        defer i.rwMux.Unlock()
        _, isExist := i.table.Files[fileId]
        if isExist </span><span class="cov8" title="1">{
                delete(i.table.Files, fileId)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("file id %v does not exist", fileId)</span>
}

func (i *FileIndex) UpdateFile(fileId uint32, firstBlock uint32, lastBlock uint32, name string, blocks []byte) error <span class="cov8" title="1">{
        i.rwMux.Lock()
        defer i.rwMux.Unlock()
        if !i.checkFileExist(fileId) </span><span class="cov0" title="0">{
                return fmt.Errorf("file id %v does not exist", fileId)
        }</span>
        <span class="cov8" title="1">i.table.Files[fileId] = &amp;File{Id: fileId, FirstBlock: firstBlock, LastBlock: lastBlock, Name: name, RMapBlocks: blocks}
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.25.0
//         protoc        v3.14.0
// source: fileIndex.proto

package fileIndex

import (
        reflect "reflect"
        sync "sync"

        proto "github.com/golang/protobuf/proto"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        _ "google.golang.org/protobuf/types/descriptorpb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Table struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Files       map[uint32]*File `protobuf:"bytes,1,rep,name=Files,proto3" json:"Files,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        NumberFiles uint32           `protobuf:"varint,2,opt,name=NumberFiles,proto3" json:"NumberFiles,omitempty"` // number of records
}

func (x *Table) Reset() <span class="cov8" title="1">{
        *x = Table{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_fileIndex_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Table) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Table) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Table) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_fileIndex_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Table.ProtoReflect.Descriptor instead.
func (*Table) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_fileIndex_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Table) GetFiles() map[uint32]*File <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Files
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Table) GetNumberFiles() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NumberFiles
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type File struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id         uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`                 // id
        FirstBlock uint32 `protobuf:"varint,2,opt,name=firstBlock,proto3" json:"firstBlock,omitempty"` // first block number
        LastBlock  uint32 `protobuf:"varint,3,opt,name=lastBlock,proto3" json:"lastBlock,omitempty"`   // last block number
        RMapBlocks []byte `protobuf:"bytes,4,opt,name=rMapBlocks,proto3" json:"rMapBlocks,omitempty"`  // roaring bitmap
        Name       string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`              //  Record Next=5; // use pointer of
}

func (x *File) Reset() <span class="cov0" title="0">{
        *x = File{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_fileIndex_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *File) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*File) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *File) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_fileIndex_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use File.ProtoReflect.Descriptor instead.
func (*File) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_fileIndex_proto_rawDescGZIP(), []int{1}
}</span>

func (x *File) GetId() uint32 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *File) GetFirstBlock() uint32 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.FirstBlock
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *File) GetLastBlock() uint32 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.LastBlock
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *File) GetRMapBlocks() []byte <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.RMapBlocks
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *File) GetName() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_fileIndex_proto protoreflect.FileDescriptor

var file_fileIndex_proto_rawDesc = []byte{
        0x0a, 0x0f, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x1a, 0x20, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa7,
        0x01, 0x0a, 0x05, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x31, 0x0a, 0x05, 0x46, 0x69, 0x6c, 0x65,
        0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x6e,
        0x64, 0x65, 0x78, 0x2e, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x52, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x4e,
        0x75, 0x6d, 0x62, 0x65, 0x72, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x0b, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x1a, 0x49, 0x0a,
        0x0a, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b,
        0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x25, 0x0a,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x66,
        0x69, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x88, 0x01, 0x0a, 0x04, 0x46, 0x69, 0x6c,
        0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69,
        0x64, 0x12, 0x1e, 0x0a, 0x0a, 0x66, 0x69, 0x72, 0x73, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x66, 0x69, 0x72, 0x73, 0x74, 0x42, 0x6c, 0x6f, 0x63,
        0x6b, 0x12, 0x1c, 0x0a, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x12,
        0x1e, 0x0a, 0x0a, 0x72, 0x4d, 0x61, 0x70, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x0c, 0x52, 0x0a, 0x72, 0x4d, 0x61, 0x70, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x12,
        0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_fileIndex_proto_rawDescOnce sync.Once
        file_fileIndex_proto_rawDescData = file_fileIndex_proto_rawDesc
)

func file_fileIndex_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_fileIndex_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_fileIndex_proto_rawDescData = protoimpl.X.CompressGZIP(file_fileIndex_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_fileIndex_proto_rawDescData</span>
}

var (
        file_fileIndex_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
        file_fileIndex_proto_goTypes  = []interface{}{
                (*Table)(nil), // 0: fileIndex.Table
                (*File)(nil),  // 1: fileIndex.File
                nil,           // 2: fileIndex.Table.FilesEntry
        }
)

var file_fileIndex_proto_depIdxs = []int32{
        2, // 0: fileIndex.Table.Files:type_name -&gt; fileIndex.Table.FilesEntry
        1, // 1: fileIndex.Table.FilesEntry.value:type_name -&gt; fileIndex.File
        2, // [2:2] is the sub-list for method output_type
        2, // [2:2] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_fileIndex_proto_init() }</span>
func file_fileIndex_proto_init() <span class="cov8" title="1">{
        if File_fileIndex_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_fileIndex_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Table); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_fileIndex_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*File); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_fileIndex_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_fileIndex_proto_goTypes,
                DependencyIndexes: file_fileIndex_proto_depIdxs,
                MessageInfos:      file_fileIndex_proto_msgTypes,
        }.Build()
        File_fileIndex_proto = out.File
        file_fileIndex_proto_rawDesc = nil
        file_fileIndex_proto_goTypes = nil
        file_fileIndex_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package fileIndex

import "google.golang.org/protobuf/proto"

// NewFileIndex
func NewFileIndex() (fi *FileIndex) <span class="cov8" title="1">{
        return &amp;FileIndex{table: &amp;Table{Files: make(map[uint32]*File), NumberFiles: 0}}
}</span>

func (i *FileIndex) GenerateBinary() (data []byte, err error) <span class="cov8" title="1">{
        i.rwMux.Lock()
        defer i.rwMux.Unlock()
        data, err = proto.Marshal(i.table)
        return
}</span>

func (i *FileIndex) InitFromBinary(data []byte) (err error) <span class="cov8" title="1">{
        err = proto.Unmarshal(data, i.table)
        return err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package fsEngine

import (
        "crypto/rand"
        "errors"
        "fmt"
        Header_ "github.com/fanap-infra/FSEngine/internal/Header"
        "github.com/fanap-infra/FSEngine/internal/virtualFile"
        "github.com/fanap-infra/FSEngine/pkg/utils"
        "os"
        "path/filepath"
        "strings"

        "github.com/fanap-infra/log"
)

func CreateFileSystem(path string, size int64, blockSize uint32, log *log.Logger) (*FSEngine, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, errors.New("path cannot be empty")
        }</span>

        <span class="cov8" title="1">if blockSize &lt; HeaderByteSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Block size must be greater than %v", blockSize)
        }</span>

        <span class="cov8" title="1">if utils.FileExists(path) </span><span class="cov0" title="0">{
                return nil, errors.New("file already exists")
        }</span>
        <span class="cov8" title="1">if size%int64(blockSize) != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("File size must be divisible by %v", blockSize)
        }</span>
        <span class="cov8" title="1">if size &lt; int64(blockSize*60) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("File size is too small, Minimum size is %v", blockSize*60)
        }</span>

        <span class="cov8" title="1">file, err := utils.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o777)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">token := make([]byte, blockSize)
        _, err = rand.Read(token)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorv("generate rand token ", "err", err.Error())
                return nil, err
        }</span>
        <span class="cov8" title="1">n, err := file.WriteAt(token, size-int64(blockSize))
        if err != nil </span><span class="cov0" title="0">{
                log.Warnv("write token ", "err", err.Error())
                return nil, err
        }</span>
        <span class="cov8" title="1">if uint32(n) != blockSize </span><span class="cov0" title="0">{
                log.Warnv("Does not write completely ", "n", n)
                return nil, fmt.Errorf("block size is %v, but written size is %v", blockSize, n)
        }</span>

        <span class="cov8" title="1">fs := &amp;FSEngine{
                file:      file,
                size:      size,
                version:   FileSystemVersion,
                blocks:    uint32(size / int64(blockSize)),
                blockSize: blockSize,
                openFiles: make(map[uint32]*virtualFile.VirtualFile),
                log:       log,
        }

        fileName := filepath.Base(path)
        headerPath := strings.Replace(path, fileName, "Header.Beh", 1)
        headerFS, err := Header_.CreateHeaderFS(headerPath, size, blockSize, log, fs)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorv("Can not create header file ", "err", err.Error())
        }</span>

        <span class="cov8" title="1">fs.header = headerFS

        return fs, nil</span>
}

func ParseFileSystem(path string, log *log.Logger) (*FSEngine, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, errors.New("path cannot be empty")
        }</span>
        <span class="cov8" title="1">size, err := utils.FileSize(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">file, err := utils.OpenFile(path, os.O_RDWR, 0o777)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fs := &amp;FSEngine{
                file:      file,
                size:      size,
                openFiles: make(map[uint32]*virtualFile.VirtualFile),
                log:       log,
        }

        fileName := filepath.Base(path)
        headerPath := strings.Replace(path, fileName, "Header.Beh", 1)
        hfs, err := Header_.ParseHeaderFS(headerPath, log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fs.header = hfs
        fs.blockSize = hfs.GetBlockSize()
        fs.blocks = hfs.GetBlocksNumber()

        return fs, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
